From e5d99a70335b514489d35eace354ac3765b3d95a Mon Sep 17 00:00:00 2001
From: Sergiy Gladkyy <sgladkyy@productengine.com>
Date: Sun, 5 Jun 2022 01:00:02 +0300
Source: COMCAST
License: Apache-2.0
Upstream-Status: Pending
Subject: [PATCH] SERXIONE-600: LocationSync Network check

Reason for change: LocationSync depends on Network but it might not be available early on boot-up
Implements:  network availability check
Test Procedure: discussed in the ticket
Signed-off-by: Sergiy Gladkyy <sgladkyy@productengine.com>
Risks: None

Change-Id: Ie3a4718a04b555ad24c0f6fccd2761b5f8492220
---
 LocationSync/LocationSync.cpp | 100 +++++++++++++++++++++++++++++++++-
 LocationSync/LocationSync.h   |  13 ++++-
 2 files changed, 109 insertions(+), 4 deletions(-)

diff --git a/LocationSync/LocationSync.cpp b/LocationSync/LocationSync.cpp
index 7acedc6e..a16815d5 100644
--- a/LocationSync/LocationSync.cpp
+++ b/LocationSync/LocationSync.cpp
@@ -18,6 +18,8 @@
  */
  
 #include "LocationSync.h"
+#include <functional>
+#include <curl/curl.h>
 
 #define API_VERSION_NUMBER_MAJOR 1
 #define API_VERSION_NUMBER_MINOR 0
@@ -28,6 +30,8 @@ namespace Plugin {
 
     SERVICE_REGISTRATION(LocationSync, API_VERSION_NUMBER_MAJOR, API_VERSION_NUMBER_MINOR, API_VERSION_NUMBER_PATCH);
 
+	const u_int32_t NETCONTROL_CHECK_TIME_IN_SECONDS(5);
+	const u_int32_t NETCONTROL_CHECK_MAX_ATTEMPTS(90);
     static Core::ProxyPoolType<Web::Response> responseFactory(4);
     static Core::ProxyPoolType<Web::JSONBodyType<LocationSync::Data>> jsonResponseFactory(4);
 
@@ -62,7 +66,31 @@ namespace Plugin {
             _skipURL = static_cast<uint16_t>(service->WebPrefix().length());
             _source = config.Source.Value();
             _service = service;
-
+            TRACE(Trace::Fatal, (_T("Starting network reachability check. Source: %s, network check every %d ms")
+                    , _source.c_str()
+                    , NETCONTROL_CHECK_TIME_IN_SECONDS
+                    ));
+            bool done = false;
+            bool networkReachable = false;
+            int remainingAttempts = NETCONTROL_CHECK_MAX_ATTEMPTS;
+            do {
+                WPE_INET_Result connectivity = getConnectivity(_source);
+                networkReachable = (connectivity == WPE_INET_CONNECTED);
+                remainingAttempts--;
+                TRACE(Trace::Fatal, (_T("Network is %s"), networkReachable ? "REACHABLE" : "UNREACHABLE"));
+                done = networkReachable || (remainingAttempts <= 0);
+                if (!done)
+                {
+                    TRACE(Trace::Fatal, (_T("Doing one more reachability check in %d sec."), NETCONTROL_CHECK_TIME_IN_SECONDS));
+                    sleep(NETCONTROL_CHECK_TIME_IN_SECONDS);
+                }
+            } while (!done);
+            TRACE(Trace::Fatal, (_T("Network reachability check ended.")));
+            if (!networkReachable)
+            {
+                TRACE(Trace::Fatal, (_T("LocationSync was unable to reach an external endpoint after %d attempts. That was a preliminary check."), NETCONTROL_CHECK_MAX_ATTEMPTS));
+            }
+            TRACE(Trace::Fatal, (_T("Proceeding with LocationSync init.")));
             _sink.Initialize(config.Source.Value(), config.Interval.Value(), config.Retries.Value());
         } else {
             result = _T("URL for retrieving location is incorrect !!!");
@@ -75,7 +103,6 @@ namespace Plugin {
     void LocationSync::Deinitialize(PluginHost::IShell* service VARIABLE_IS_NOT_USED) /* override */
     {
         ASSERT(_service == service);
-
         _sink.Deinitialize();
     }
 
@@ -164,5 +191,74 @@ namespace Plugin {
         }
     }
 
+    static size_t writeCurlResponse(void *ptr, size_t size, size_t nmemb, std::string stream)
+    {
+        size_t realsize = size * nmemb;
+        std::string temp(static_cast<const char*>(ptr), realsize);
+        stream.append(temp);
+        return realsize;
+    }
+
+    LocationSync::WPE_INET_Result
+    LocationSync::getConnectivity(const std::string& source)
+    {
+        TRACE(Trace::Fatal, (_T("Using internal connectivity check")));
+        WPE_INET_Result connectivity = WPE_INET_DISCONNECTED;
+        std::string response;
+        long http_code = 200;
+        CURLcode res = CURLE_OK;
+        CURL *curl_handle = nullptr;
+        struct curl_slist *list = nullptr;
+        static unsigned int idx = 0;
+        long connect_timeout = 2L;
+
+        curl_handle = curl_easy_init();
+        static std::vector<std::string>urls;
+        if (source.length() > 0)
+        {
+            urls.emplace_back(source.c_str());
+        } else {
+            TRACE(Trace::Fatal, (_T("The supplied remote url is invalid, ignored")));
+        }
+        // some well known Internet addresses
+        urls.emplace_back("comcast.net");
+        urls.emplace_back("example.com");
+
+        std::string url = urls.at(idx);
+        TRACE(Trace::Fatal, (_T("Checking connectivity against %s. Test method: getting HTTP headers, max-time: %lds"), url.c_str(), connect_timeout));
+
+        list = curl_slist_append(list, "Connection: close");
+        if (curl_handle &&
+            !curl_easy_setopt(curl_handle, CURLOPT_URL, url.c_str()) &&
+            !curl_easy_setopt(curl_handle, CURLOPT_HTTPGET,1) &&
+            !curl_easy_setopt(curl_handle, CURLOPT_TIMEOUT, connect_timeout) &&
+            !curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, writeCurlResponse) &&
+            !curl_easy_setopt(curl_handle, CURLOPT_HTTPHEADER, list) &&
+            !curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, &response))
+        {
+            res = curl_easy_perform(curl_handle);
+            if(curl_easy_getinfo(curl_handle, CURLINFO_RESPONSE_CODE, &http_code) != CURLE_OK)
+            {
+                TRACE(Trace::Fatal, (_T("curl_easy_getinfo failed")));
+            }
+            TRACE(Trace::Fatal, (_T("curl response code: %d; http response code: %ld"), res, http_code ));
+            curl_slist_free_all(list);
+            curl_easy_cleanup(curl_handle);
+        } else {
+            TRACE(Trace::Fatal, (_T("Could not perform connectivity check with curl. Reachability is unknown")));
+            connectivity = WPE_INET_UNKNOWN;
+        }
+
+        if (res == CURLE_OK) {
+            connectivity = WPE_INET_CONNECTED;
+        } else {
+            TRACE(Trace::Fatal, (_T("Reachability check failure; curl response: %d, http code: %ld"), res, http_code));
+            TRACE(Trace::Fatal, (_T("Assuming Network is not ready yet")));
+            connectivity = WPE_INET_DISCONNECTED;
+        }
+        ++idx;
+        if(idx >= urls.size()) idx = 0;
+        return connectivity;
+    }
 } // namespace Plugin
 } // namespace WPEFramework
diff --git a/LocationSync/LocationSync.h b/LocationSync/LocationSync.h
index 4bfcf64f..73911616 100644
--- a/LocationSync/LocationSync.h
+++ b/LocationSync/LocationSync.h
@@ -24,9 +24,9 @@
 #include <interfaces/json/JsonData_LocationSync.h>
 #include "Module.h"
 
+
 namespace WPEFramework {
 namespace Plugin {
-
     class LocationSync : public PluginHost::IPlugin, public PluginHost::IWeb, public PluginHost::JSONRPC {
     public:
         class Data : public Core::JSON::Container {
@@ -199,8 +199,17 @@ namespace Plugin {
         uint32_t endpoint_sync();
         uint32_t get_location(JsonData::LocationSync::LocationData& response) const;
         void event_locationchange();
-
         void SyncedLocation();
+        enum WPE_INET_Result : int {
+            WPE_INET_UNDEFINED = -50
+            , WPE_INET_UNRESOLVED = -3
+            , WPE_INET_TIMEDOUT = -2
+            , WPE_INET_UNKNOWN = -1
+            , WPE_INET_DISCONNECTED = 0
+            , WPE_INET_CONNECTED = 1
+        };
+        WPE_INET_Result getConnectivity(const std::string&);
+        void onNetControlTimer();
 
     private:
         uint16_t _skipURL;
-- 
2.17.1

