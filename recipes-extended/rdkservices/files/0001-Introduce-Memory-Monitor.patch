From 9571a805c72dd29c320f3db7e32ddf274ce0e680 Mon Sep 17 00:00:00 2001
From: josekutty_kuriakose <josekutty_kuriakose@cable.comcast.com>
Date: Mon, 16 May 2022 01:29:22 +0000
Subject: [PATCH] Introduce Memory Monitor

---
 CMakeLists.txt               |   5 +-
 MemMonitor/CMakeLists.txt    |  54 ++++++++
 MemMonitor/MemMonitor.config |   3 +
 MemMonitor/MemMonitor.cpp    | 247 +++++++++++++++++++++++++++++++++++
 MemMonitor/MemMonitor.h      | 104 +++++++++++++++
 MemMonitor/MemMonitor.json   |   7 +
 MemMonitor/Module.cpp        |  22 ++++
 MemMonitor/Module.h          |  29 ++++
 8 files changed, 470 insertions(+), 1 deletion(-)
 create mode 100644 MemMonitor/CMakeLists.txt
 create mode 100755 MemMonitor/MemMonitor.config
 create mode 100644 MemMonitor/MemMonitor.cpp
 create mode 100644 MemMonitor/MemMonitor.h
 create mode 100644 MemMonitor/MemMonitor.json
 create mode 100644 MemMonitor/Module.cpp
 create mode 100644 MemMonitor/Module.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 19d7c3bb..4b9ca7ce 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -24,6 +24,7 @@ find_package(WPEFramework)
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_SOURCE_DIR}/cmake/")
 
 option(COMCAST_CONFIG "Comcast services configuration" ON)
+option(PLUGIN_MEMMONITOR "Mem Monitor support" ON)
 if(COMCAST_CONFIG)
     include(services.cmake)
 endif()
@@ -66,7 +67,9 @@ endif()
 if(PLUGIN_SYSTEMSERVICES)
     add_subdirectory(SystemServices)
 endif()
-
+if(PLUGIN_MEMMONITOR)
+    add_subdirectory(MemMonitor)
+endif()
 if(PLUGIN_MAINTENANCEMANAGER)
     add_subdirectory(MaintenanceManager)
 endif()
diff --git a/MemMonitor/CMakeLists.txt b/MemMonitor/CMakeLists.txt
new file mode 100644
index 00000000..5c77944e
--- /dev/null
+++ b/MemMonitor/CMakeLists.txt
@@ -0,0 +1,54 @@
+# If not stated otherwise in this file or this component's license file the
+# following copyright and licenses apply:
+#
+# Copyright 2020 RDK Management
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+set(PLUGIN_NAME MemMonitor)
+set(MODULE_NAME ${NAMESPACE}${PLUGIN_NAME})
+
+set(PLUGIN_MEMMONITOR_AUTOSTART "false" CACHE STRING "Automatically start Memory Monitor plugin")
+set(PLUGIN_MEMMONITOR_MODE "Off" CACHE STRING "Controls if the plugin should run in its own process, in process or remote")
+
+find_package(${NAMESPACE}Plugins REQUIRED)
+find_package(${NAMESPACE}Definitions REQUIRED)
+find_package(CompileSettingsDebug CONFIG REQUIRED)
+
+find_package(IARMBus REQUIRED)
+
+add_library(${MODULE_NAME} SHARED
+    MemMonitor.cpp
+    Module.cpp
+    ../helpers/utils.cpp
+    ../helpers/tptimer.cpp
+)
+target_include_directories(${MODULE_NAME} PRIVATE
+        ../helpers
+        ${IARMBUS_INCLUDE_DIRS})
+
+set_target_properties(${MODULE_NAME} PROPERTIES
+        CXX_STANDARD 11
+        CXX_STANDARD_REQUIRED YES)
+
+target_link_libraries(${MODULE_NAME}
+    PRIVATE
+        CompileSettingsDebug::CompileSettingsDebug
+        ${NAMESPACE}Plugins::${NAMESPACE}Plugins
+        ${NAMESPACE}Definitions::${NAMESPACE}Definitions
+        ${IARMBUS_LIBRARIES})
+
+install(TARGETS ${MODULE_NAME}
+    DESTINATION lib/${STORAGE_DIRECTORY}/plugins)
+
+write_config(${PLUGIN_NAME})
\ No newline at end of file
diff --git a/MemMonitor/MemMonitor.config b/MemMonitor/MemMonitor.config
new file mode 100755
index 00000000..4ae3c951
--- /dev/null
+++ b/MemMonitor/MemMonitor.config
@@ -0,0 +1,3 @@
+set (autostart ${PLUGIN_MEMMONITOR_AUTOSTART})
+set (callsign "org.rdk.MemMonitor")
+set (startuporder 30)
diff --git a/MemMonitor/MemMonitor.cpp b/MemMonitor/MemMonitor.cpp
new file mode 100644
index 00000000..2067ef4e
--- /dev/null
+++ b/MemMonitor/MemMonitor.cpp
@@ -0,0 +1,247 @@
+#include "MemMonitor.h"
+#include <iostream>
+#define SERVER_DETAILS "127.0.0.1:9998"
+#define SUBSCRIPTION_CALLSIGN "org.rdk.RDKShell"
+#define SUBSCRIPTION_CALLSIGN_VER SUBSCRIPTION_CALLSIGN ".1"
+
+#define SUBSCRIPTION_LOW_MEMORY_EVENT "onDeviceCriticallyLowRamWarning"
+#define SUBSCRIPTION_ONKEY_EVENT "onKeyEvent"
+#define SUBSCRIPTION_ONLAUNCHED_EVENT "onLaunched"
+#define SUBSCRIPTION_ONDESTROYED_EVENT "onDestroyed"
+
+#define MY_VERSION "1.37b"
+#define RECONNECTION_TIME_IN_MILLISECONDS 5500
+//#define LAUNCH_URL "https://apps.rdkcentral.com/rdk-apps/accelerator-home-ui/index.html#menu"
+//#define LAUNCH_URL "https://apps.rdkcentral.com/dev/Device_UI_3.6/index.html#menu"
+#define LAUNCH_URL "http://127.0.0.1:50050/lxresui/index.html#menu"
+#define THUNDER_TIMEOUT 2000
+
+namespace WPEFramework
+{
+    namespace Plugin
+    {
+        static std::string gThunderAccessValue = SERVER_DETAILS;
+        static std::string sThunderSecurityToken;
+        void MemMonitor::onLowMemoryEvent(const JsonObject &parameters)
+        {
+            string message;
+            parameters.ToString(message);
+            LOGINFO("[Jose] [Low memory  event], %s : %s Res app running ? %d ", __FUNCTION__, C_STR(message), m_isResAppRunning);
+
+            if (parameters.HasLabel("ram"))
+            {
+                PluginHost::WorkerPool::Instance().Submit(Job::Create(this, OFFLOAD));
+            }
+        }
+        void MemMonitor::onKeyEvent(const JsonObject &parameters)
+        {
+            string message, clients;
+            if (parameters.HasLabel("keycode"))
+            {
+                if (!parameters["keyDown"].Boolean() && parameters["keycode"].Number() == 36)
+                {
+                    // Is there an active app ?
+                    if (!activeCallsign.empty())
+                    {
+                        // destroy active app.
+                        PluginHost::WorkerPool::Instance().Submit(Job::Create(this, REMOVE_ACTIVE_APP));
+                    }
+                    else
+                    {
+                        if (!m_isResAppRunning && !m_launchInitiated)
+                        {
+                            LOGINFO("[Jose] Hot key ... Launching resident app ");
+                            PluginHost::WorkerPool::Instance().Submit(Job::Create(this, LAUNCH));
+                        }
+                        else
+                        {
+                            LOGINFO("[Jose] Hot key ... Resident app status launched: %d, islaunching : %d",
+                                    m_isResAppRunning, m_launchInitiated);
+                        }
+                    }
+                }
+            }
+        }
+        void MemMonitor::onLaunched(const JsonObject &parameters)
+        {
+            if (parameters.HasLabel("client"))
+            {
+                activeCallsign = parameters["client"].String();
+                LOGINFO("[Jose] Launch notification  ...%s  ", C_STR(activeCallsign));
+
+                if (Utils::String::stringContains(activeCallsign, "residentapp"))
+                {
+                    m_callMutex.Lock();
+                    m_isResAppRunning = true;
+                    m_launchInitiated = false;
+                    m_callMutex.Unlock();
+                }
+            }
+        }
+        void MemMonitor::onDestroyed(const JsonObject &parameters)
+        {
+            // Case 1.Focused app is not referenceapp.
+            LOGINFO("[Jose] m_isResAppRunning =%d m_launchInitiated = %d ", m_isResAppRunning, m_launchInitiated);
+            if (parameters.HasLabel("client"))
+            {
+                string destroyedApp = parameters["client"].String();
+                if (!Utils::String::stringContains(destroyedApp, "residentapp") &&
+                    !m_isResAppRunning && !m_launchInitiated)
+                {
+                    launchResidentApp();
+                }
+                else if (Utils::String::stringContains(destroyedApp, "residentapp"))
+                {
+                    m_callMutex.Lock();
+                    m_isResAppRunning = false;
+                    m_launchInitiated = false;
+                    m_callMutex.Unlock();
+                }
+            }
+        }
+
+        void MemMonitor::Dispatch(JOBTYPE jobType)
+        {
+            string message, clients;
+            JsonObject req, res;
+            uint32_t status;
+
+            switch (jobType)
+            {
+            case LAUNCH:
+                launchResidentApp();
+                break;
+            case OFFLOAD:
+                req["callsign"] = "ResidentApp";
+                status = m_remoteObject->Invoke<JsonObject, JsonObject>(THUNDER_TIMEOUT, _T("destroy"), req, res);
+                LOGINFO("destroyed residentApp, status : %d", (Core::ERROR_NONE == status));
+                break;
+            case REMOVE_ACTIVE_APP:
+                req["callsign"] = activeCallsign.c_str();
+                status = m_remoteObject->Invoke<JsonObject, JsonObject>(THUNDER_TIMEOUT, _T("destroy"), req, res);
+                break;
+            }
+        }
+        void MemMonitor::launchResidentApp()
+        {
+            JsonObject req, res;
+            uint32_t status;
+            string message;
+
+            req["callsign"] = "ResidentApp";
+            req["type"] = "ResidentApp";
+            req["visible"] = true;
+            req["focus"] = true;
+            req["uri"] = LAUNCH_URL;
+
+            status = m_remoteObject->Invoke<JsonObject, JsonObject>(THUNDER_TIMEOUT, _T("launch"), req, res);
+            res.ToString(message);
+            m_callMutex.Lock();
+            m_launchInitiated = true;
+            m_callMutex.Unlock();
+            LOGINFO("[Jose] Launched residentapp . status : %d,  msg %s ",
+                    (status == Core::ERROR_NONE), C_STR(message));
+        }
+
+        SERVICE_REGISTRATION(MemMonitor, 1, 0);
+
+        MemMonitor::MemMonitor() : AbstractPlugin(2),
+                                   m_subscribedToEvents(false),
+                                   m_remoteObject(nullptr),
+                                   m_isResAppRunning(false),
+                                   m_launchInitiated(false)
+        {
+            LOGINFO();
+            m_timer.connect(std::bind(&MemMonitor::onTimer, this));
+        }
+        MemMonitor::~MemMonitor()
+        {
+        }
+        const string MemMonitor::Initialize(PluginHost::IShell * /* service */)
+        {
+            LOGINFO();
+
+            LOGINFO("[Jose] version %s ", MY_VERSION);
+            m_timer.start(RECONNECTION_TIME_IN_MILLISECONDS);
+            Core::SystemInfo::SetEnvironment(_T("THUNDER_ACCESS"), _T(SERVER_DETAILS));
+            m_remoteObject = new WPEFramework::JSONRPC::LinkType<WPEFramework::Core::JSON::IElement>(_T(SUBSCRIPTION_CALLSIGN_VER));
+            return "";
+        }
+
+        void MemMonitor::Deinitialize(PluginHost::IShell * /* service */)
+        {
+
+            LOGINFO();
+            if (m_subscribedToEvents)
+            {
+                m_remoteObject->Unsubscribe(THUNDER_TIMEOUT, _T(SUBSCRIPTION_LOW_MEMORY_EVENT));
+                m_remoteObject->Unsubscribe(THUNDER_TIMEOUT, _T(SUBSCRIPTION_ONKEY_EVENT));
+                m_remoteObject->Unsubscribe(THUNDER_TIMEOUT, _T(SUBSCRIPTION_ONLAUNCHED_EVENT));
+                m_remoteObject->Unsubscribe(THUNDER_TIMEOUT, _T(SUBSCRIPTION_ONDESTROYED_EVENT));
+                m_subscribedToEvents = false;
+                // delete m_remoteObject;
+            }
+            if (m_timer.isActive())
+            {
+                m_timer.stop();
+            }
+        }
+
+        string MemMonitor::Information() const
+        {
+            return (string("{\"service \": \"org.rdk.MemMonitor\"}"));
+        }
+        void MemMonitor::onTimer()
+        {
+            m_callMutex.Lock();
+            if (!m_subscribedToEvents)
+            {
+                SubscribeToEvents();
+            }
+            if (m_subscribedToEvents)
+            {
+                if (m_timer.isActive())
+                {
+                    m_timer.stop();
+                    LOGINFO("[Jose] Timer stopped.");
+                }
+                LOGINFO("[Jose]Subscription completed.");
+            }
+            m_callMutex.Unlock();
+        }
+        void MemMonitor::SubscribeToEvents()
+        {
+            LOGINFO("[Jose] Attempting event subscription");
+
+            if (Utils::isPluginActivated(SUBSCRIPTION_CALLSIGN))
+            {
+                uint32_t status = Core::ERROR_NONE;
+
+                std::string serviceCallsign = "org.rdk.RDKShell.1";
+
+                m_remoteObject->Subscribe<JsonObject>(THUNDER_TIMEOUT, _T(SUBSCRIPTION_LOW_MEMORY_EVENT), &MemMonitor::onLowMemoryEvent, this);
+                m_remoteObject->Subscribe<JsonObject>(THUNDER_TIMEOUT, _T(SUBSCRIPTION_ONKEY_EVENT), &MemMonitor::onKeyEvent, this);
+                m_remoteObject->Subscribe<JsonObject>(THUNDER_TIMEOUT, _T(SUBSCRIPTION_ONLAUNCHED_EVENT), &MemMonitor::onLaunched, this);
+                m_remoteObject->Subscribe<JsonObject>(THUNDER_TIMEOUT, _T(SUBSCRIPTION_ONDESTROYED_EVENT), &MemMonitor::onDestroyed, this);
+
+                m_subscribedToEvents = true;
+
+                JsonObject req, res;
+                status = m_remoteObject->Invoke<JsonObject, JsonObject>(THUNDER_TIMEOUT, "getClients", req, res);
+                if (Core::ERROR_NONE == status)
+                {
+                    string clients = res["clients"].String();
+                    m_isResAppRunning = (clients.find("residentapp") != std::string::npos);
+                }
+                else
+                {
+                    LOGINFO("[Jose] Failed to invoke getClients.");
+                }
+            }
+            else
+            {
+                LOGINFO("[Jose] RDKShell is not yet active. Wait for it.. ");
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/MemMonitor/MemMonitor.h b/MemMonitor/MemMonitor.h
new file mode 100644
index 00000000..e3959b19
--- /dev/null
+++ b/MemMonitor/MemMonitor.h
@@ -0,0 +1,104 @@
+/*
+ * If not stated otherwise in this file or this component's LICENSE file the
+ * following copyright and licenses apply:
+ *
+ * Copyright 2020 RDK Management
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#pragma once
+#include <mutex>
+#include "Module.h"
+#include "utils.h"
+#include "AbstractPlugin.h"
+#include "tptimer.h"
+
+namespace WPEFramework
+{
+    namespace Plugin
+    {
+        enum JOBTYPE
+        {
+            LAUNCH,
+            OFFLOAD,
+            REMOVE_ACTIVE_APP
+        };
+
+        class MemMonitor : public AbstractPlugin
+        {
+
+            class EXTERNAL Job : public Core::IDispatch
+            {
+            public:
+                Job(MemMonitor *monitor, JOBTYPE _jobType)
+                    : _monitor(monitor), jobType(_jobType)
+                {
+
+                    ASSERT(_monitor != nulllptr);
+                }
+                virtual ~Job()
+                {
+                }
+
+            private:
+                Job() = delete;
+                Job(const Job &) = delete;
+                Job &operator=(const Job &) = delete;
+
+            public:
+                static Core::ProxyType<Core::IDispatch> Create(MemMonitor *mon, JOBTYPE jobType)
+                {
+                    return (Core::proxy_cast<Core::IDispatch>(Core::ProxyType<Job>::Create(mon, jobType)));
+                }
+                virtual void Dispatch()
+                {
+                    _monitor->Dispatch(jobType);
+                }
+
+            private:
+                MemMonitor *_monitor;
+                JOBTYPE jobType;
+            };
+
+            MemMonitor(const MemMonitor &) = delete;
+            MemMonitor &operator=(const MemMonitor &) = delete;
+
+            void Dispatch(JOBTYPE keycode);
+
+            void SubscribeToEvents();
+            void onLowMemoryEvent(const JsonObject &parameters);
+            void onSuspended(const JsonObject &parameters);
+            void onDestroyed(const JsonObject &parameters);
+            void onLaunched(const JsonObject &parameters);
+            void onKeyEvent(const JsonObject &parameters);
+            
+            bool m_subscribedToEvents;
+            void onTimer();
+            void launchResidentApp();
+
+            TpTimer m_timer;
+            mutable Core::CriticalSection m_callMutex;
+            WPEFramework::JSONRPC::LinkType<WPEFramework::Core::JSON::IElement> *m_remoteObject;
+            volatile bool m_isResAppRunning, m_launchInitiated;
+            string activeCallsign;
+
+        public:
+            MemMonitor();
+            virtual ~MemMonitor();
+            virtual const string Initialize(PluginHost::IShell *service) override;
+            virtual void Deinitialize(PluginHost::IShell *service) override;
+            virtual string Information() const override;
+        };
+    }
+}
\ No newline at end of file
diff --git a/MemMonitor/MemMonitor.json b/MemMonitor/MemMonitor.json
new file mode 100644
index 00000000..c79fbfae
--- /dev/null
+++ b/MemMonitor/MemMonitor.json
@@ -0,0 +1,7 @@
+{
+ "locator":"libWPEFrameworkMemMonitor.so",
+ "classname":"MemMonitor",
+ "callsign":"org.rdk.MemMonitor",
+ "autostart":false,
+ "startuporder":30
+}
\ No newline at end of file
diff --git a/MemMonitor/Module.cpp b/MemMonitor/Module.cpp
new file mode 100644
index 00000000..ce759b61
--- /dev/null
+++ b/MemMonitor/Module.cpp
@@ -0,0 +1,22 @@
+/**
+* If not stated otherwise in this file or this component's LICENSE
+* file the following copyright and licenses apply:
+*
+* Copyright 2019 RDK Management
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+**/
+
+#include "Module.h"
+
+MODULE_NAME_DECLARATION(BUILD_REFERENCE)
diff --git a/MemMonitor/Module.h b/MemMonitor/Module.h
new file mode 100644
index 00000000..b40de11b
--- /dev/null
+++ b/MemMonitor/Module.h
@@ -0,0 +1,29 @@
+/**
+* If not stated otherwise in this file or this component's LICENSE
+* file the following copyright and licenses apply:
+*
+* Copyright 2019 RDK Management
+*
+* Licensed under the Apache License, Version 2.0 (the "License");
+* you may not use this file except in compliance with the License.
+* You may obtain a copy of the License at
+*
+* http://www.apache.org/licenses/LICENSE-2.0
+*
+* Unless required by applicable law or agreed to in writing, software
+* distributed under the License is distributed on an "AS IS" BASIS,
+* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+* See the License for the specific language governing permissions and
+* limitations under the License.
+**/
+
+#pragma once
+#ifndef MODULE_NAME
+#define MODULE_NAME Plugin_MemMonitor
+#endif
+
+#include <plugins/plugins.h>
+#include <tracing/tracing.h>
+
+#undef EXTERNAL
+#define EXTERNAL
