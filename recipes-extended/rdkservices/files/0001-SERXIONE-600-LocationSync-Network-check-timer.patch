From 0d7c62c2e8ed6285147ded7135d298b35384f69c Mon Sep 17 00:00:00 2001
From: Sergiy Gladkyy <sgladkyy@productengine.com>
Date: Tue, 30 Aug 2022 20:38:30 +0200
Subject: [PATCH] SERXIONE-600: LocationSync Network check (timer)

Source: COMCAST
License: Apache-2.0
Upstream-Status: Pending
Reason for change: LocationSync depends on Network but it might not be available early on boot-up
Implements:  network availability check
Test Procedure: discussed in the ticket
Signed-off-by: Sergiy Gladkyy <sgladkyy@productengine.com>
Risks: None

Change-Id: Ia4b66e10f2f2a8f191eca2df59e39ea31bdc67dd
---
 LocationSync/CMakeLists.txt   |  10 ++-
 LocationSync/LocationSync.cpp | 152 +++++++++++++++++++++++++++++++++-
 LocationSync/LocationSync.h   |  49 ++++++++++-
 3 files changed, 206 insertions(+), 5 deletions(-)

diff --git a/LocationSync/CMakeLists.txt b/LocationSync/CMakeLists.txt
index a5909c24..8e0881e5 100644
--- a/LocationSync/CMakeLists.txt
+++ b/LocationSync/CMakeLists.txt
@@ -35,8 +35,11 @@ add_library(${MODULE_NAME} SHARED
     LocationSync.cpp
     LocationService.cpp
     LocationSyncJsonRpc.cpp
+    ../helpers/UtilsSecurityToken.cpp
 )
 
+target_compile_definitions(${MODULE_NAME} PRIVATE MODULE_NAME=Plugin_${PLUGIN_NAME})
+
 set_target_properties(${MODULE_NAME} PROPERTIES
         CXX_STANDARD 11
         CXX_STANDARD_REQUIRED YES)
@@ -44,8 +47,11 @@ set_target_properties(${MODULE_NAME} PROPERTIES
 target_link_libraries(${MODULE_NAME} 
     PRIVATE
         CompileSettingsDebug::CompileSettingsDebug
-        ${NAMESPACE}Plugins::${NAMESPACE}Plugins)
-
+        ${NAMESPACE}Plugins::${NAMESPACE}Plugins
+        ${NAMESPACE}SecurityUtil
+)
+target_include_directories(${MODULE_NAME} PRIVATE ../helpers)
+target_include_directories(${MODULE_NAME} PRIVATE ./)
 install(TARGETS ${MODULE_NAME} 
     DESTINATION lib/${STORAGE_DIRECTORY}/plugins)
 
diff --git a/LocationSync/LocationSync.cpp b/LocationSync/LocationSync.cpp
index 7acedc6e..1ef4e437 100644
--- a/LocationSync/LocationSync.cpp
+++ b/LocationSync/LocationSync.cpp
@@ -18,10 +18,13 @@
  */
  
 #include "LocationSync.h"
+#include "UtilsSecurityToken.h"
+#include <memory>
 
 #define API_VERSION_NUMBER_MAJOR 1
 #define API_VERSION_NUMBER_MINOR 0
 #define API_VERSION_NUMBER_PATCH 0
+#define SERVER_DETAILS  "127.0.0.1:9998"
 
 namespace WPEFramework {
 namespace Plugin {
@@ -37,10 +40,14 @@ namespace Plugin {
     LocationSync::LocationSync()
         : _skipURL(0)
         , _source()
+                , _interval(0)
+                , _retries(0)
         , _sink(this)
         , _service(nullptr)
+                , _networkReady(false)
     {
         RegisterAll();
+            _netControlTimer.connect(std::bind(&LocationSync::onNetControlTimer, this));
     }
 #ifdef __WINDOWS__
 #pragma warning(default : 4355)
@@ -61,9 +68,19 @@ namespace Plugin {
         if (LocationService::IsSupported(config.Source.Value()) == Core::ERROR_NONE) {
             _skipURL = static_cast<uint16_t>(service->WebPrefix().length());
             _source = config.Source.Value();
+                _interval = config.Interval.Value();
+                _retries = config.Retries.Value();
             _service = service;
-
-            _sink.Initialize(config.Source.Value(), config.Interval.Value(), config.Retries.Value());
+            TRACE(Trace::Information, (_T("Starting netcontrol timer. Source: %s, interval: %d, retries: %d, network check every %d ms")
+                    , _source.c_str()
+                    , _interval
+                    , _retries
+                    , _interval * 1000
+            ));
+            if(_netControlTimer.isActive()) {
+                _netControlTimer.stop();
+            }
+            _netControlTimer.start(_interval * 1000);
         } else {
             result = _T("URL for retrieving location is incorrect !!!");
         }
@@ -76,6 +93,9 @@ namespace Plugin {
     {
         ASSERT(_service == service);
 
+            if(_netControlTimer.isActive()) {
+                _netControlTimer.stop();
+            }
         _sink.Deinitialize();
     }
 
@@ -164,5 +184,133 @@ namespace Plugin {
         }
     }
 
+        void LocationSync::onNetControlTimer()
+        {
+            static uint8_t remainingAttempts = _retries;
+            bool networkReachable = getConnectivity();
+            remainingAttempts--;
+            TRACE(Trace::Information, (_T("Network is %s"), networkReachable ? "REACHABLE" : "UNREACHABLE"));
+            if (networkReachable || remainingAttempts <= 0)
+            {
+                _netControlTimer.stop();
+                TRACE(Trace::Information, (_T("Network reachability monitoring stopped.")));
+                TRACE(Trace::Information, (_T("Proceeding with LocationService init.")));
+                _sink.Initialize(_source, _interval, _retries);
+            } else {
+                TRACE(Trace::Information, (_T("Doing one more reachability check in %d sec, remaining attempts: %d"), _interval, remainingAttempts));
+            }
+        }
+        bool LocationSync::getConnectivity()
+        {
+            JsonObject joGetParams;
+            JsonObject joGetResult;
+            std::string callsign = "org.rdk.Network.1";
+            std::string token;
+            bool result = false;
+            /* check if plugin active */
+            bool pluginActive = Utils::isPluginActivated("org.rdk.Network");
+            if (!pluginActive) {
+                TRACE(Trace::Fatal, ("Network plugin is not activated \n"));
+                result = false;
+            } else {
+                Utils::SecurityToken::getSecurityToken(token);
+                string query = "token=" + token;
+                Core::SystemInfo::SetEnvironment(_T("THUNDER_ACCESS"), _T(SERVER_DETAILS));
+                auto *thunder_client = new WPEFramework::JSONRPC::LinkType<WPEFramework::Core::JSON::IElement>(callsign.c_str(),"",false, query);
+                if (thunder_client != nullptr) {
+                    uint32_t status = thunder_client->Invoke<JsonObject, JsonObject>(5000, "isConnectedToInternet", joGetParams, joGetResult);
+                    if (status > 0) {
+                        TRACE(Trace::Fatal, ("%s call failed %d", callsign.c_str(), status));
+                        result = false;
+                    } else if (joGetResult.HasLabel("connectedToInternet")) {
+                        TRACE(Trace::Information, ("connectedToInternet status %s",(joGetResult["connectedToInternet"].Boolean())? "true":"false"));
+                        result = joGetResult["connectedToInternet"].Boolean();
+                    } else {
+                        result = false;
+                    }
+                    delete thunder_client;
+                } else {
+                    TRACE(Trace::Fatal, ("thunder client failed"));
+                    result = false;
+                }
+            }
+            return result;
+        }
+
+        // TIMER
+        Timer::Timer() :
+                baseTimer(64 * 1024, "ThunderPluginBaseTimer")
+                , m_timerJob(this)
+                , m_isActive(false)
+                , m_isSingleShot(false)
+                , m_intervalInMs(-1)
+        {}
+
+        Timer::~Timer()
+        {
+            stop();
+        }
+
+        bool Timer::isActive()
+        {
+            return m_isActive;
+        }
+
+        void Timer::stop()
+        {
+            baseTimer.Revoke(m_timerJob);
+            m_isActive = false;
+        }
+
+        void Timer::start()
+        {
+            baseTimer.Revoke(m_timerJob);
+            baseTimer.Schedule(Core::Time::Now().Add(m_intervalInMs), m_timerJob);
+            m_isActive = true;
+        }
+
+        void Timer::start(int msec)
+        {
+            setInterval(msec);
+            start();
+        }
+
+        void Timer::setSingleShot(bool val)
+        {
+            m_isSingleShot = val;
+        }
+
+        void Timer::setInterval(int msec)
+        {
+            m_intervalInMs = msec;
+        }
+
+        void Timer::connect(std::function< void() > callback)
+        {
+            onTimeoutCallback = callback;
+        }
+
+        void Timer::Timed()
+        {
+            if(onTimeoutCallback != nullptr) {
+                onTimeoutCallback();
+            }
+            // stop in case of a single shot call; start again if it has not been stopped
+            if (m_isActive) {
+                if(m_isSingleShot) {
+                    stop();
+                } else{
+                    start();
+                }
+            }
+        }
+
+        uint64_t TimerJob::Timed(const uint64_t scheduledTime)
+        {
+            if(m_timer) {
+                m_timer->Timed();
+            }
+            return 0;
+        }
 } // namespace Plugin
 } // namespace WPEFramework
diff --git a/LocationSync/LocationSync.h b/LocationSync/LocationSync.h
index 4bfcf64f..41d92b4e 100644
--- a/LocationSync/LocationSync.h
+++ b/LocationSync/LocationSync.h
@@ -26,6 +26,48 @@
 
 namespace WPEFramework {
 namespace Plugin {
+        class Timer;
+        class TimerJob
+        {
+        private:
+            TimerJob() = delete;
+            TimerJob& operator=(const TimerJob& RHS) = delete;
+        public:
+            TimerJob(WPEFramework::Plugin::Timer* tpt) : m_timer(tpt) { }
+            TimerJob(const TimerJob& copy) : m_timer(copy.m_timer) { }
+            ~TimerJob() {}
+            inline bool operator==(const TimerJob& RHS) const
+            {
+                return(m_timer == RHS.m_timer);
+            }
+        public:
+            uint64_t Timed(const uint64_t scheduledTime);
+        private:
+            WPEFramework::Plugin::Timer* m_timer;
+        };
+
+        class Timer
+        {
+        public:
+            Timer();
+            ~Timer();
+            bool isActive();
+            void stop();
+            void start();
+            void start(int msec);
+            void setSingleShot(bool val);
+            void setInterval(int msec);
+            void connect(std::function< void() > callback);
+        private:
+            void Timed();
+            WPEFramework::Core::TimerType<TimerJob> baseTimer;
+            TimerJob m_timerJob;
+            bool m_isActive;
+            bool m_isSingleShot;
+            int m_intervalInMs;
+            std::function< void() > onTimeoutCallback;
+            friend class TimerJob;
+        };
 
     class LocationSync : public PluginHost::IPlugin, public PluginHost::IWeb, public PluginHost::JSONRPC {
     public:
@@ -201,12 +243,17 @@ namespace Plugin {
         void event_locationchange();
 
         void SyncedLocation();
-
+        bool getConnectivity();
+        void onNetControlTimer();
     private:
         uint16_t _skipURL;
         string _source;
+        uint16_t _interval;
+        uint8_t _retries;
         Core::Sink<Notification> _sink;
         PluginHost::IShell* _service;
+        bool _networkReady;
+        Timer _netControlTimer;
     };
 
 } // namespace Plugin
-- 
2.32.1 (Apple Git-133)

